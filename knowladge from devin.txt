To properly fix memory leaks in the WFL codebase:

1. **Break reference cycles** by converting strong references (`Rc<RefCell<T>>`) to weak references (`Weak<RefCell<T>>`) for back-references, particularly:
   - Change `FunctionValue::env` from `Rc<RefCell<Environment>>` to `Weak<RefCell<Environment>>`
   - Update all constructors to use `Rc::downgrade(&env)` instead of `Rc::clone(&env)`
   - Audit for other cycles in object methods and callbacks

2. **Optimize parser memory usage** by:
   - Replacing `.cloned()` token peeks with references
   - Using `reserve()` for vectors that collect parameters, arguments, or statements
   - Implementing string interning with `once_cell::sync::Lazy<HashSet<Arc<str>>>` for identifiers and keywords
   - Deferring error formatting instead of using eager `format!` calls in hot loops

3. **Limit debug output** to prevent memory explosion:
   - Truncate collections after 16 elements with a count of remaining items
   - Limit long strings to first 128 bytes with ellipsis
   - Ensure call frames are properly popped on return
   - Clear retained data after generating debug reports
   - Add doc comments explaining truncation limits

4. **Verify fixes** with:
   - Regression tests that verify reference counts return to expected values
   - Memory usage tracking to ensure stability between runs
   - Leak sanitizer checks using `ASAN_OPTIONS=detect_leaks=1`
   
   When addressing memory issues in the WFL runtime's debug report generation, focus on these key areas:

1. **Cycle detection in Value printing**: Implement cycle detection using a `HashSet<*const ()>` to track visited container addresses and prevent infinite recursion when printing self-referential data structures.

2. **Call stack preservation**: Ensure call frames are preserved until after debug reports are generated, either by delaying frame popping or by attaching a cloned stack to runtime errors.

3. **Invariant enforcement**: Add invariant checks at critical points (start/end of interpret, execute_block, evaluate_expression) to verify state consistency, particularly for loop flags and call stack depth.

4. **Collection truncation**: Limit the output size of large collections (â‰¥16 items) in debug reports to prevent memory explosion.

These patterns apply to any debugging infrastructure that needs to handle potentially cyclic data structures or preserve execution context for post-mortem analysis.

When debugging issues in the WFL interpreter or compiler, follow this systematic approach:

1. **Reproduce and Minimize**: 
   - Create a deterministic test case by isolating the issue
   - Reduce to the minimal code that still reproduces the bug
   - For interpreter hangs (like the `count` keyword issue), isolate the specific statement causing the problem

2. **Create a Regression Test**:
   - Add the minimal reproduction to `tests/regression/`
   - Use `#[should_panic]` or expected output assertions
   - Push the failing test to ensure CI catches regressions

3. **Instrument the Code Path**:
   - Add `tracing` spans or `println!` statements at key execution points
   - Log variable scopes and identifiers during lookup
   - Use `tokio::time::timeout` to detect infinite loops

4. **Use a Debugger**:
   - Run with `rust-lldb target/debug/wfl` and set breakpoints
   - Analyze backtraces to identify recursion or deadlocks
   - Build with `cargo build -Zlocation-detail` for detailed stack traces

5. **Hypothesis and Fix**:
   - Form a specific hypothesis about the cause
   - Write a unit test that would fail if the hypothesis is wrong
   - Make minimal changes to fix the issue
   - Run all tests and `cargo clippy` to verify

6. **Document the Fix**:
   - Keep the regression test in the test suite
   - Update `CHANGELOG.md` with a description of the fix
   - Add workarounds to documentation if needed

This approach is particularly effective for WFL-specific issues like the interpreter hang when using `count` directly in a display statement inside a count loop.

When encountering compiler errors claiming that standard library functions like `std::env::set_var` or `std::env::remove_var` are unsafe (error E0133), the issue is likely due to shadowing of the `std::env` module rather than the functions actually being unsafe. To fix this without using `unsafe` blocks:

1. Use fully qualified syntax to bypass potential shadowing: 
   ```rust
   ::std::env::set_var("ENV_VAR_NAME", value)
   ::std::env::remove_var("ENV_VAR_NAME")
   ```

2. If the issue persists, check for:
   - Accidental imports like `use some_crate::env;` that replace `std::env`
   - Macro or attribute interference that might be redefining standard functions
   - Custom wrappers that might be confusing type resolution

This approach avoids introducing unnecessary `unsafe` blocks while ensuring the code uses the actual standard library implementations.

When fixing reference cycles between Environment and FunctionValue in the WFL interpreter, ensure all creation points are updated to use weak references. The FunctionValue struct should use `Weak<RefCell<Environment>>` instead of `Rc<RefCell<Environment>>`, but also remember to:

1. Update all construction points including:
   - The ActionDefinition statement handler which should use `Rc::downgrade(&env)` instead of `Rc::clone(&env)`
   - Any test helpers that directly create FunctionValue instances
   - The call_function method which needs to upgrade the weak reference and handle the case when the environment no longer exists

2. Clean up duplicate code:
   - Remove any duplicate struct definitions with the old `Rc` reference
   - Remove stale constructors that still use `Rc::clone(&env)`
   - Ensure there are no duplicate implementations of methods like `call_function` that still use the old pattern

3. Verify changes:
   - Run `git grep -n "env: Rc::clone(&env)" -- src` to find any remaining strong references
   - Run `git grep -n "struct FunctionValue" -- src` to ensure only one definition exists
   - Run `git grep -n "async fn call_function" -- src` to check for duplicate implementations

This approach prevents memory leaks while maintaining the parent-child relationship between environments.

When implementing REPL commands or other features that interact with async code in WFL, avoid using `runtime.block_on()` within command handlers that are already running inside a Tokio runtime. This causes the "Cannot start a runtime from within a runtime" panic error. For REPL commands like `.help` and `.exit` that don't require async functionality, implement them synchronously without using `block_on()`. For commands that do require async operations, use proper async context propagation rather than nested runtime instances.

To implement asynchronous file operations in WFL:

1. **Parser Implementation**:
   - Add parser support for the syntax pattern `open file at "path" and read content as variable`
   - Implement `wait for` wrapper by creating a `WaitForStatement` that contains the inner statement
   - Use existing AST structures like `ReadFileStatement` and `OpenFileStatement`

2. **Interpreter Implementation**:
   - Implement file opening by storing file handles in the environment
   - Implement file reading by evaluating the path or looking up existing handles
   - For initial MVP, execute `WaitForStatement` synchronously by directly executing the inner statement
   - Ensure timeout safety using the interpreter's existing deadline mechanism

3. **Testing**:
   - Update existing tests in `interpreter/io_tests.rs` to use the new syntax
   - Add parser unit tests to verify correct parsing of the new syntax
   - Verify functionality by checking that file contents are correctly read and displayed
   
Implementing asynchronous I/O in WFL requires:
1. **Natural Language I/O Syntax**: Design grammar for operations like `open file at "path" and read content` and `open url "link" and read response` that map to AST function calls or special AST nodes.
2. **Tokio Integration**: Add Tokio as a dependency and modify the interpreter's evaluation functions to be async (return `Future`s). Use Tokio's async APIs for file operations (`tokio::fs`) and HTTP clients like Reqwest for network operations.
3. **Async Evaluation Model**: Refactor interpreter functions like `eval_expr` to be async, allowing them to await async Rust functions. Consider implementing WFL async as direct coroutines using Rust's async/await underneath.
4. **Resource Management**: Ensure resources are properly closed after I/O operations, either automatically or through explicit `close` operations in WFL.
5. **Error Handling**: Implement error handling for I/O operations using WFL's `try/when/otherwise` construct, either by returning Result-like values or implementing exception-like behavior.
6. **Testing**: Create test programs that perform file reads and HTTP requests, including tests for error conditions like file-not-found or network failures.
7. **Async-Safe Resource Handling**: When implementing resource management with async operations:
   - Avoid holding RefCell references across await points
   - Prefer tokio::sync::Mutex over std::cell::RefCell for async-aware locking
   - Ensure lock guards are dropped before awaiting futures
   - Structure code to scope-limit borrows so they don't cross await boundaries
   
For Rust projects, a comprehensive CI/CD pipeline should include:

1. **Matrix builds for cross-platform support**:
   - Windows: Use `windows-latest` with `x86_64-pc-windows-msvc` target
   - Linux: Use `ubuntu-latest` with `x86_64-unknown-linux-gnu` target
   - Note: macOS builds should be excluded from the WFL project's CI/CD pipeline as requested by the project maintainer

2. **Caching mechanisms**:
   - Use `Swatinem/rust-cache@v2` with shared-key based on target platform

3. **Skip-if-unchanged logic**:
   - Check for changes using `git diff --name-status` to catch deletions/renames
   - Include all relevant file types (`.rs`, `Cargo.toml`, `build.rs`, workflow files)
   - Store previous build SHA in release notes or artifacts

4. **Platform-specific packaging tools**:
   - Windows: `cargo-wix` + WiX Toolset (`choco install wix`) for MSI packages
   - Linux: `cargo-deb` for Debian packages and tar.gz archives (verify available versions in crates.io before pinning)

5. **Version injection**:
   - Pass version to packaging tools explicitly:
     - `--define Version=$VERSION` for cargo-wix
     - `DEB_VERSION=$VERSION` for cargo-deb

6. **GitHub Actions integration**:
   - Ensure GitHub CLI is installed with `actions/setup-gh` or equivalent
   - Authenticate with `gh auth login --with-token <<<"$GITHUB_TOKEN"`
   - Quote or loop through file patterns when using `find` with multiple extensions

7. **Tool version pinning**:
   - When pinning Rust tool versions, verify their existence in crates.io first
   - Use `cargo install <tool>` without version constraints to get the latest compatible version if a specific version isn't available
   - For critical tools, consider using `--locked` flag only without version pinning to ensure reproducible builds while allowing compatible versions
   
   The WFL project enforces strict code formatting rules through CI checks using `cargo fmt`. When making changes:

1. **Run formatting check locally** before submitting PRs with `cargo fmt --all -- --check`
2. **Format whitespace carefully** - trailing whitespace is not allowed
3. **Follow Rust formatting conventions** for multi-line expressions, particularly:
   - Format assertions with parameters on separate lines
   - Format string concatenation and interpolation across multiple lines
   - Format function calls with multiple arguments on separate lines

This prevents CI failures and ensures consistent code style across the project.

Implement a three-layer approach to automate Rust code formatting with rustfmt:

1. **Local formatting before commit**:
   - Configure editors with "format on save" (VS Code: `"editor.formatOnSave": true`)
   - Use CLI with `cargo fmt --all` or create a cargo alias

2. **CI check to block unformatted code**:
   - Add a GitHub Actions job in `.github/workflows/ci.yml` that runs `cargo fmt --all -- --check`
   - Use actions/checkout@v4 and actions-rs/toolchain@v1 with stable toolchain

3. **Auto-fix workflow (optional)**:
   - Create `.github/workflows/auto-fmt.yml` triggered when CI fails
   - Configure to checkout code, run formatter, and commit changes automatically
   - Consider using peter-evans/create-pull-request for separate formatting PRs

4. **Project-wide style configuration**:
   - Add `rustfmt.toml` in repo root with custom rules (e.g., `max_width = 100`)
   - Ensures consistent formatting across all environments

This approach prevents formatting issues from reaching the repository while providing safeguards and automation for when they do occur.

When implementing code quality tools for the WFL project:

1. **Rule Organization**:
   - Implement a trait-based rule system for linting rules
   - Consider moving helper utilities (like snake_case conversion, diff generator) into a shared `utils` sub-module to avoid duplication between linter and fixer

2. **CLI Behavior**:
   - Define clear precedence or error handling for mutually exclusive flags (e.g., when both `--in-place` and `--diff` are provided)
   - Implement specific exit codes for CI integration: 0 for success (no diagnostics), 1 for lint/analyze warnings, 2 for parser/type errors

3. **Configuration Handling**:
   - Decide on a strategy for cascading configs (nearest-file-wins or merge) and document it
   - Add support for inline suppression with pragmas (e.g., `# wfl-lint: allow(LINT-INDENT)`)

4. **Performance Considerations**:
   - Add performance guards in CI to prevent accidental O(NÂ²) scans when rules multiply
   - Consider using the visitor pattern for the pretty-printer instead of large match blocks for better extensibility

5. **Documentation**:
   - Add short code descriptions to docs so users know how to allow or suppress specific rules
   - Create a documentation file (e.g., `docs/quality_suite.md`) with rule list, rationale, config reference, and IDE hooks
   
   After lexical analysis (tokenization) and parsing (AST construction), the next phases in a compiler pipeline are typically:

1. **Semantic Analysis**: Ensures the program is meaningful and adheres to language rules beyond syntax. This includes type checking, ensuring variables are declared before use, and validating that operations are performed on compatible types.

2. **Symbol Resolution**: Links identifiers (variables, functions, etc.) to their definitions in the code. This process creates a symbol table that maps each identifier to information about its type, scope, and memory location, enabling correct code generation and efficient runtime execution.

These phases would follow the parser implementation in the WFL compiler development roadmap.

The WFL compiler follows a structured development roadmap with sequential milestones:
1. Lexical Analysis (Tokenization)
2. Parsing (AST Construction)
3. Semantic Analysis and Symbol Resolution
4. Static Type Checking
5. Bytecode Compilation

Each milestone builds upon the previous one, with the Static Type Checker (Milestone 6) following the Semantic Analysis phase and preceding the Bytecode Compiler implementation. When implementing new features, ensure they align with the current milestone and maintain compatibility with previous stages of the compiler pipeline.

The WFL interpreter handles loop control flow through a dedicated enum structure:

1. **LoopControl Enum**: Should be defined in `interpreter/mod.rs` with variants `Continue`, `Break`, `Exit`, and `None` (default).

2. **Interpreter Return Type**: Loop-related methods should return `Result<(Value, LoopControl), RuntimeError>` to propagate control flow signals.

3. **Loop Execution Behavior**:
   - `Continue` â†’ Skip to next iteration
   - `Break` â†’ Exit current loop
   - `Exit` â†’ Bubble up one level (allowing inner loops to terminate outer loops)
   - If `Exit` reaches the top level without being consumed, convert to a runtime error

4. **Error Handling**: Runtime control flow misuse should be reported through `RuntimeError::new(msg, line, col)`, following the pattern used for other runtime errors like count loop exhaustion.

When implementing error handling for WFL syntax errors:

1. **Maintain consistency across similar constructs**: Apply the same error detection and reporting approach to all statements with required keywords in fixed positions (`store` â†’ `as`, `create` â†’ `as`, `change` â†’ `to`).

2. **Structure error messages in two parts**:
   - Main message: Concise description of the error (e.g., "Expected 'as' after identifier(s), but found IntLiteral(4)")
   - Helpful note: Example of correct syntax (e.g., "Did you mean: store a as 4?")

3. **Provide tailored suggestions**: When possible, capture the actual identifiers and literals from the user's code to construct specific, contextual examples in error messages.

4. **Consider utility functions**: For similar parsing patterns (like variable declarations and assignments), create utility functions that handle the common pattern while accepting the specific expected keywords as parameters.

5. **Test all error cases**: Ensure test coverage for all variations of missing keyword errors to prevent regressions.

When implementing execution timeout features in the WFL interpreter:

1. **Check Granularity**: Place timeout checks at the beginning of the `execute_statement` method, which automatically covers all statements including those in nested blocks, function bodies, and loops. Additional checks at loop entrances are helpful but not required for correctness.

2. **Config Module Placement**: Keep configuration modules at the crate root (e.g., `src/config.rs`) and expose them as `pub mod config;` from `lib.rs`. This maintains single-responsibility, enables reuse across CLI and REPL, and avoids cyclic dependencies.

3. **Logging Approach**: Use debug-level logging for configuration loading (e.g., `log::debug!("Loaded timeout override: {} s from {}", secs, file.display());`). Don't log warnings for missing files or parse errors - silently fall back to defaults instead.

4. **Expression Evaluation**: Don't add timeout checks inside `evaluate_expression` unless profiling shows long-running pure-expression paths. Per-statement checks provide sufficient protection with minimal overhead.

WFL (Web-First Language) requires a standard library with built-in functionalities including: basic I/O (print), string operations (length, concatenation, substring), math utilities (rounding, random numbers), collections (list/array with push/pop), and potentially date/time utilities. These can be implemented as intrinsics in the interpreter or as part of a standard library written in WFL itself, with performance-critical functions better implemented in Rust.

To implement HTTP GET/POST functionality in the WFL interpreter:
1. The interpreter already has `Statement::HttpGetStatement` and `Statement::HttpPostStatement` AST nodes
2. Use the existing `IoClient` struct which contains async helpers `http_get()` and `http_post()` using the reqwest library
3. In the interpreter's `execute_statement` method, extract the URL (and data for POST) from expressions, evaluate them, and call the appropriate IoClient method
4. Store the response body into the specified variable as a Text value
5. Return RuntimeError with the I/O message on network failure
6. The type checker already sets the captured variable to `Type::Text` for both statements, so no changes needed there

When implementing I/O operations in the WFL language:

1. **AST Field Naming**: Field names in AST nodes should accurately reflect their purpose. For example, in `ReadFileStatement` and `WriteFileStatement`, the field should be named `path` rather than `file` when it represents a file path expression, to keep the AST self-documenting and avoid confusion.

2. **IoClient Usage**: The `IoClient` struct in `interpreter/mod.rs` provides all necessary async I/O functionality including `open_file`, `read_file`, `write_file`, and `close_file` methods, as well as HTTP helpers. This implementation already handles Tokio integration with Mutex-protected handle maps, so no additional crate work is required.

3. **Error Handling**: IoClient methods return `Result<T, String>` which should be converted to `RuntimeError` in the interpreter to enable WFL scripts to catch errors with `try/when` blocks. For example:
```rust
match self.io_client.read_file(&handle).await {
  Ok(text) => env.borrow_mut().define(var, Value::Text(text.into())),
  Err(msg) => return Err(RuntimeError::new(msg, line, column)),
}
```

When creating Debian packages with cargo-deb for the WFL project:

1. **Required Cargo.toml fields**:
   - The `license` field must be specified in Cargo.toml (e.g., "MIT", "Apache-2.0")
   - Either the `authors` field must be present OR the `--maintainer` flag must be provided to cargo-deb
   - Missing these fields will cause the packaging to fail with errors like "license field is missing" or "package must have a maintainer specified"

2. **Command options**:
   - Use `--no-build` when the binary is already built to avoid rebuilding
   - Specify target architecture with `--target` parameter when cross-compiling
   - Use `--asset` flag to include configuration files in the format `source:destination:mode` (e.g., `--asset "target/x86_64-unknown-linux-gnu/release/package/.wflcfg:etc/wfl/.wflcfg:644"`)

3. **Configuration file handling**:
   - Include `.wflcfg` configuration files in the package at `/etc/wfl/.wflcfg` for system-wide installations
   - Standard configuration includes timeout settings, logging configuration, and debug report settings

4. **Output file location**:
   - cargo-deb places the generated .deb file in `target/<target>/debian/` directory, not in the `target/<target>/release/` directory
   - When writing smoke tests or installation scripts, use `find` commands that search in the correct location: `find target/<target>/debian -name "*.deb"`
   - Incorrect path patterns in workflow scripts will result in empty variables and "cannot access archive ''" errors during installation
   - The WFL binary expects this configuration file to run properly; missing configuration files can cause "No such file or directory" errors

4. **Alternative configuration via Cargo.toml**:
   - Configuration can also be specified in Cargo.toml under `[package.metadata.deb]` section
   - Example: `assets = [["target/release/wfl", "usr/bin/", "755"], ["target/x86_64-unknown-linux-gnu/release/package/.wflcfg", "etc/wfl/.wflcfg", "644"]]`
   - The `--asset` flag is more practical for dynamically generated files in CI workflows
   
When creating macOS packages with cargo-bundle for the WFL project:

1. **Icon file requirements**:
   - Icons must be valid PNG files with correct CRC checksums
   - Format errors with message "Failed to create app icon" and "CRC error" indicate corrupted PNG data
   - Use standard image creation tools rather than base64 encoding/decoding to ensure proper file format
   - Test icon files locally before committing to ensure they can be properly processed by cargo-bundle

2. **Configuration file handling**:
   - Include `.wflcfg` configuration files in the package at `Applications/WFL.app/Contents/MacOS/`
   - Standard configuration includes timeout settings, logging configuration, and debug report settings

3. **Bundle metadata requirements**:
   - The `[package.metadata.bundle]` section in Cargo.toml must include valid icon paths
   - Icon paths must point to existing, properly formatted PNG files

4. **Signing requirements**:
   - When using `--sign "-"` with productbuild, ensure the environment supports this no-signing option
   - Error "Could not find appropriate signing identity for '-'" indicates the productbuild command requires a valid signing identity even when SIGNING_SKIP is true
   - For CI environments, may need to use `--sign ""` (empty string) instead of `--sign "-"` or configure the environment to accept the dash as a valid no-sign indicator
   - Test signing options locally before committing to ensure they work in the target CI environment

5. **Binary verification and symlink creation**:
   - Verify the binary exists in the app bundle after running `cargo bundle` with commands like `test -f path/to/bundle/Contents/MacOS/wfl`
   - Create a symlink in `/usr/local/bin` pointing to the app bundle's binary for global CLI access
   - Ensure the binary has executable permissions with `chmod 755` on the bundled binary
   - Add verification steps in CI to check that both the app bundle binary and symlink work correctly
   - Include `/usr/local/bin` in PATH during testing to ensure the symlink is accessible

6. **Architecture considerations**:
   - GitHub's macOS runners are now ARM-based (Apple Silicon)
   - When cross-compiling for x86_64 on ARM runners, install Rosetta (`softwareupdate --install-rosetta --agree-to-license`)
   - Consider building native ARM64 binaries or universal binaries for better performance on modern Macs
   - A `description` field is required in the `[package.metadata.bundle]` section
   - Missing the description field will cause the error: "missing field `description` for key `package`"

4. **Signing requirements**:
   - When using `--sign "-"` with productbuild, ensure the environment supports this no-signing option
   - Error "Could not find appropriate signing identity for '-'" indicates the productbuild command requires a valid signing identity even when SIGNING_SKIP is true
   - For CI environments, may need to use `--sign ""` (empty string) instead of `--sign "-"` or configure the environment to accept the dash as a valid no-sign indicator
   - Test signing options locally before committing to ensure they work in the target CI environment
   - The main [package] section must include a description field for cargo-bundle to work correctly
   - Missing description field results in error: "missing field `description` for key `package`"

4. **Signing requirements**:
   - When using `--sign "-"` with productbuild, ensure the environment supports this no-signing option
   - Error "Could not find appropriate signing identity for '-'" indicates the productbuild command requires a valid signing identity even when SIGNING_SKIP is true
   - For CI environments, may need to use `--sign ""` (empty string) instead of `--sign "-"` or configure the environment to accept the dash as a valid no-sign indicator
   - Test signing options locally before committing to ensure they work in the target CI environment

5. **Binary verification**:
   - After installation, verify the binary exists at `/Applications/WFL.app/Contents/MacOS/wfl`
   - Verify the symlink exists at `/usr/local/bin/wfl` pointing to the application binary
   - Error "No such file or directory" when executing the binary indicates packaging issues
   - Always include verification steps in CI to ensure the binary is correctly packaged and executable
   
   When implementing memory management in the WFL interpreter, particularly when dealing with reference cycles:

1. **Environment references**: 
   - `Environment::parent` should use `Weak<RefCell<Environment>>` to prevent reference cycles
   - `FunctionValue::env` can use `Rc<RefCell<Environment>>` to allow closures to outlive their defining scope
   - Create helper constructors like `Environment::new_child(parent)` that return `Rc<RefCell<Self>>` to keep code concise

2. **Verification**:
   - After implementation changes, verify with `Rc::strong_count(&global_env)` to ensure it returns to 1 after interpreter drop
   - Test that closures can outlive their defining scope with a specific test case (e.g., counter function that increments a captured variable)

3. **Code patterns**:
   - When changing from `Weak` to `Rc`, remove or replace error handling for "Parent environment no longer exists" with `unreachable!()` assertions
   - Be aware that leaving old upgrade-check code will trigger "dead-code" lints in Clippy
   
   There's a specific issue with how the WFL interpreter handles the "count" keyword in expressions inside count loops. When using "count" directly in a display statement inside a count loop (e.g., `display "Count: " with count`), the interpreter may hang. A workaround is to store the count value in a separate variable and use that variable in expressions. For example:

```wfl
// Problematic code that may cause the interpreter to hang
count from 1 to 5:
    display "Count: " with count
end count

// Workaround that avoids the issue
count from 1 to 5:
    store loopcounter as count
    display "Count: " with loopcounter
end count
```

This issue should be investigated when implementing loop handling in the interpreter.

There's a specific issue with how the WFL interpreter handles the "count" keyword in expressions inside count loops. When using "count" directly in a display statement inside a count loop (e.g., `display "Count: " with count`), the interpreter may hang. A workaround is to store the count value in a separate variable and use that variable in expressions. For example:

```wfl
// Problematic code that may cause the interpreter to hang
count from 1 to 5:
    display "Count: " with count
end count

// Workaround that avoids the issue
count from 1 to 5:
    store loopcounter as count
    display "Count: " with loopcounter
end count
```

This issue should be investigated when implementing loop handling in the interpreter.

When creating helper methods for environment construction in the WFL interpreter:
1. Use descriptive names like `new_child_env` rather than generic names like `new_child` to avoid IDE autocompletion conflicts with existing methods
2. Mark frequently used environment constructors with `#[inline]` to optimize performance in hot paths
3. Maintain a single canonical constructor for child scopes for consistency across the codebase
4. When implementing environment-related functionality, ensure all call sites use the same pattern for creating child environments

When adding helper methods to the Environment struct in WFL:
1. Use descriptive names like `new_child_env` rather than generic names like `new_child` to avoid clashing with existing methods in IDE autocompletion
2. Mark helper methods with `#[inline]` attribute to improve performance in hot paths
3. Maintain consistency by using the same helper method for all similar operations (e.g., use `new_child_env` for all child scope creation)
4. When changing environment handling patterns, ensure all related code (like foreach loops, count loops, etc.) consistently uses the same pattern

When implementing error handling in the WFL parser, especially for statements like `store`, `create`, or `change`:

1. Include helpful hints in error messages that suggest the correct syntax, such as "= Hint: try 'store x as 3'" when the `as` keyword is missing.

2. For multi-word identifiers followed by values without the required keyword (e.g., `store user name "Alice"`), emit clear errors that include the full variable name in the message: "Expected 'as' after variable name 'user name', but found StringLiteral("Alice")".

3. When enhancing error messages, modify the `convert_parse_error()` function in `diagnostics/mod.rs` to include specific hints for common syntax errors.

4. Include line and column information in all error diagnostics to help users locate the issue in their code.

The WFL lexer should be implemented from scratch following these principles:
1. Define token types as an enum in Rust with variants for different categories (identifiers, numbers, string literals, keywords)
2. Handle special WFL features like multi-word constructs, minimal special characters, and natural language syntax
3. Implement proper handling of whitespace, comments, string literals with escape sequences, and number formats
4. Create comprehensive unit tests for the lexer, including edge cases like escaped quotes and invalid syntax
5. Consider using libraries like Pest or Logos for implementation, or implement manually with character-by-character processing
6. Maintain a clear list of reserved keywords vs. words that can be identifiers

To avoid borrow checker errors in the WFL parser's token handling:

1. **Implement a `TokenStream` wrapper** around the token iterator:
   ```rust
   pub struct TokenStream<I> where I: Iterator<Item = TokenWithPos> {
       iter: Peekable<I>,
   }
   
   impl<I> TokenStream<I> where I: Iterator<Item = TokenWithPos> {
       pub fn peek(&mut self) -> Option<&TokenWithPos> { self.iter.peek() }
       pub fn next(&mut self) -> Option<TokenWithPos> { self.iter.next() }
   }
   ```

2. **Use consistent mutable borrowing pattern**:
   - Call `peek()` once and store the reference
   - Make decisions based on the stored reference
   - Call `next()` only after the reference is no longer used

3. **Replace double-peek patterns** by storing the result of the first peek:
   ```rust
   // Instead of:
   if self.tokens.peek().is_some() && self.tokens.peek().map(...) { ... }
   
   // Use:
   let token = self.tokens.peek();
   if token.is_some() && token.map(...) { ... }
   ```

This pattern resolves mixed immutable/mutable borrow conflicts that occur when peeking at tokens while also advancing the token stream.


When testing for memory leaks in the WFL codebase, particularly with reference cycles between Environment and FunctionValue:

1. Don't just test that dropping objects doesn't cause infinite recursion - explicitly verify that reference counts reach the expected values.
2. After dropping objects that might participate in reference cycles (like `interpreter`), assert that `Rc::strong_count(&global_env)==1` to confirm that weak references properly broke the cycle.
3. This approach ensures that memory is actually freed rather than just avoiding stack overflows during drop.

When implementing parsing functions for the WFL compiler, design helper functions to be reusable across similar language constructs. For example, instead of creating specific functions like `parse_variable_name_list()`, consider more general implementations like `parse_identifier_sequence_until(stop_token: Token)` that can serve multiple statement types (store, create, change) that follow similar patterns. This approach improves maintainability and ensures consistent behavior across related language features.

For WFL release and packaging workflows:

1. **GitHub Repository**: The full canonical slug is `logbie/wfl`, making the release feed URL `https://github.com/logbie/wfl/releases/latest`

2. **Code Signing Options**:
   - For testing: Use self-signed certificates locally with `SIGNING_SKIP=true` in CI
   - For production: Obtain EV certificates (DigiCert, GlobalSign, Sectigo) for Windows and Developer ID certificates for macOS
   - Store certificates as PFX (Windows) and .p12 (macOS) files in GitHub Secrets along with their passwords
   - Interim approach: Ship unsigned packages initially and add signing when certificates are available

3. **Versioning Scheme**:
   - Format: `0.0.0-nightly.<YYYYMMDD>+<short-sha>` (e.g., `0.0.0-nightly.20250420+fd1e218`)
   - This format respects SemVer with prerelease and build-metadata segments
   - Sorts correctly in package managers
   - Packaging step should inject date and 7-character commit SHA into version string for installer metadata

When importing types across module boundaries in the WFL codebase:

1. Use full crate paths for imports from other modules to avoid cyclic-module warnings (e.g., `use crate::interpreter::error::ErrorKind;` instead of relative imports)
2. When importing multiple items from the same module, use the grouped syntax: `use std::rc::{Rc, Weak};`
3. For error types that implement `std::error::Error`, ensure the implementation is present (`impl std::error::Error for RuntimeError {}`) so existing `?` operators continue to work
4. When adding new error types or variants, update all related code paths including diagnostic reporters and error displays

When importing types across module boundaries in the WFL codebase:

1. Use full crate paths for imports from other modules to avoid cyclic-module warnings (e.g., `use crate::interpreter::error::ErrorKind;` instead of relative imports)
2. When importing multiple items from the same module, use the grouped syntax: `use std::rc::{Rc, Weak};`
3. For error types that implement `std::error::Error`, ensure the implementation is present (`impl std::error::Error for RuntimeError {}`) so existing `?` operators continue to work
4. When adding new error types or variants, update all related code paths including diagnostic reporters and error displays

When implementing Rust code for the WFL project, follow these conventions to handle unused variables:

1. Prefix intentionally unused variables with an underscore (e.g., `_line`, `_column`, `_dir_path`) in pattern matching to silence Clippy warnings without disabling lints.
2. This approach is preferred over using `#[allow(unused_variables)]` annotations as it:
   - Explicitly indicates variables are intentionally unused
   - Maintains code readability and signals intent
   - Preserves variables in patterns for potential future use
   - Complies with the CI's strict configuration (`-D warnings` flag)
3. For struct pattern matching, use the field syntax with underscores (e.g., `line: _line`) rather than tuple-style patterns.
4. Run `cargo clippy -- -D warnings` locally before committing to ensure all warnings are resolved.

This convention aligns with WFL's emphasis on code clarity and maintainability while ensuring CI checks pass successfully.

When implementing Rust code for the WFL project, follow these conventions to handle unused variables:

1. Prefix intentionally unused variables with an underscore (e.g., `_line`, `_column`, `_dir_path`) in pattern matching to silence Clippy warnings without disabling lints.
2. This approach is preferred over using `#[allow(unused_variables)]` annotations as it:
   - Explicitly indicates variables are intentionally unused
   - Maintains code readability and signals intent
   - Preserves variables in patterns for potential future use
   - Complies with the CI's strict configuration (`-D warnings` flag)
3. For struct pattern matching, use the field syntax with underscores (e.g., `line: _line`) rather than tuple-style patterns.
4. Run `cargo clippy -- -D warnings` locally before committing to ensure all warnings are resolved.

This convention aligns with WFL's emphasis on code clarity and maintainability while ensuring CI checks pass successfully.

When implementing features that require static references in the WFL project (particularly with the simplelog crate):

1. **Use `once_cell::sync::Lazy` for Static Values**: For cases where a method requires a reference with a 'static lifetime (like `set_time_format_custom` in simplelog's ConfigBuilder), use `once_cell::sync::Lazy` to create a static value:

```rust
use once_cell::sync::Lazy;
use time::format_description::FormatItem;

static TIME_FORMAT: Lazy<Vec<FormatItem>> = Lazy::new(|| {
    time::format_description::parse("[hour]:[minute]:[second].[subsecond]").unwrap()
});

// Then use it as:
let config = ConfigBuilder::new()
    .set_time_format_custom(&TIME_FORMAT)
    .set_location_level(LevelFilter::Debug)
    .build();
```

2. **Avoid Temporary Values in Method Chains**: Be cautious when passing references to temporary values in method chains, as they may be dropped before their references are used, causing E0716 errors.

3. **Understand Lifetime Requirements**: Methods that store references (like simplelog's configuration methods) may require 'static lifetimes for those references, especially if the resulting object is stored globally.

The WFL symbol table should be initialized with several categories of built-in identifiers:

1. **Keywords/reserved words**: Including `store`, `create`, `change`, `add`, `subtract`, `multiply`, `divide`, `check if`, `otherwise`, `end check`, `count from`, `for each`, etc. These should be reserved so they can't be used as identifiers.

2. **Literal identifiers**: `yes`, `no`, `nothing` (with synonyms `missing`, `undefined`) which act like `true/false/null` in other languages.

3. **Primitive type names**: `number`, `text`, `boolean`, plus composite types like `list of T`, `set of T`, `map of text to T`.

Built-in actions like `fetch` or `log info` should be loaded later during semantic analysis or at runtime rather than being hardcoded in the initial symbol table.

The WFL symbol table should be initialized with several categories of built-in identifiers:

1. **Keywords/reserved words**: Including `store`, `create`, `change`, `add`, `subtract`, `multiply`, `divide`, `check if`, `otherwise`, `end check`, `count from`, `for each`, etc. These should be reserved so they can't be used as identifiers.

2. **Literal identifiers**: `yes`, `no`, `nothing` (with synonyms `missing`, `undefined`) which act like `true/false/null` in other languages.

3. **Primitive type names**: `number`, `text`, `boolean`, plus composite types like `list of T`, `set of T`, `map of text to T`.

Built-in actions like `fetch` or `log info` should be loaded later during semantic analysis or at runtime rather than being hardcoded in the initial symbol table.

WFL standard library functions should follow these naming conventions to align with the language's principle of minimizing special characters:

1. Avoid underscores in function names (e.g., use "typeof" instead of "type_of")
2. For multi-word names, use either:
   - camelCase (e.g., "stringLength", "toNumber")
   - single descriptive words (e.g., "length", "push")

When transitioning existing code with underscores:
1. Keep thin aliases for backward compatibility (e.g., both "type_of" and "typeof" pointing to the same function)
2. Mark underscored names as deprecated in Rust
3. Update documentation and test suites to use the new identifiers

This approach maintains WFL's "minimal special characters" vision while ensuring compatibility with existing code.

WFL standard library functions should follow these naming conventions to align with the language's principle of minimizing special characters:

1. Avoid underscores in function names (e.g., use "typeof" instead of "type_of")
2. For multi-word names, use either:
   - camelCase (e.g., "stringLength", "toNumber")
   - single descriptive words (e.g., "length", "push")

When transitioning existing code with underscores:
1. Keep thin aliases for backward compatibility (e.g., both "type_of" and "typeof" pointing to the same function)
2. Mark underscored names as deprecated in Rust
3. Update documentation and test suites to use the new identifiers

This approach maintains WFL's "minimal special characters" vision while ensuring compatibility with existing code.

When implementing string interning for the WFL project:
1. Use `Arc<str>` instead of `Rc<str>` for interned strings, even when using a `Mutex` for thread safety, to ensure the interned strings are `Send + Sync` for compatibility with cross-thread Tokio tasks
2. Be prepared for a significant refactoring effort when changing token payloads (e.g., from `String` to `Arc<str>`), as it affects every pattern match on those tokens
3. Run `cargo fix --allow-dirty` after enum changes to automatically fix obvious clones that can be removed
4. Document in memory management docs that string intern pools intentionally "leak" unique identifiers (a classic intern-pool trade-off) to prevent confusion or bug reports about this expected behavior
5. Consider using a project-wide type alias (e.g., `type Ident = Arc<str>`) to maintain zero-copy benefits while minimizing code churn when refactoring string handling throughout the codebase
6. When implementing the type alias approach:
   - Define the alias in a central location and re-export it
   - Update all relevant struct fields and function signatures
   - Implement necessary trait impls (like `Display`) for the alias
   - Use `cargo check` followed by `cargo fix` to automatically resolve many conversion issues
   - Add compile-time guards to prevent regression to `String` usage
7. For complete rollout, ensure consistent HashMap key types by:
   - Updating all `HashMap<String, Value>` to `HashMap<Ident, Value>`
   - Adding `Into<Ident>` helpers for seamless conversion from `&str` and `String`
   - Using `ident.as_ref()` in string comparisons
   - Creating generic methods like `define<N: Into<Ident>>(&mut self, name: N, value: Value)`
   
   When implementing tests for the WFL project, ensure cross-platform compatibility:

1. **Platform-specific code**: Wrap platform-specific code like `set_permissions` in conditional compilation flags (`#[cfg(unix)] { ... }`) since Windows CI will fail otherwise.

2. **Dependencies management**: Add test-only dependencies like `tempfile` to `Cargo.toml` under `[dev-dependencies]` section to ensure CI builds correctly.

3. **Test reliability**: Design tests to fail reliably across platforms - for example, when testing file permission errors, use platform-agnostic approaches rather than Unix-specific permission bits.

4. **Windows compatibility**: Pay special attention to Windows compatibility as some team members run Windows, making Windows CI failures potential showstoppers.

When implementing tests for the WFL project that involve platform-specific functionality:

1. **Windows test compatibility**: For tests that use Unix-specific features (like file permissions), create parallel Windows-specific tests with appropriate annotations:
   - Use `#[cfg(unix)]` for Unix-specific tests
   - Add stub tests with `#[cfg(windows)] #[test] #[ignore]` for Windows to maintain test coverage
   
2. **Error simulation**: When testing error handling paths:
   - On Unix: Use file permission changes (`set_permissions`) to create reproducible error conditions
   - On Windows: Create alternative test approaches due to ACL differences, or use stub tests when direct equivalence isn't possible

This ensures tests run successfully on both platforms and CI passes regardless of the development environment.

When implementing tests for the WFL project that involve platform-specific functionality:

1. **Windows vs Unix differences**: Tests that work on Unix may silently succeed on Windows due to ACL quirks. Create separate test implementations for each platform.
2. **Conditional compilation**: Use `#[cfg(unix)]` and `#[cfg(windows)]` to guard platform-specific test code.
3. **Test coverage**: When a test is platform-specific, create a no-op version for the other platform to maintain test coverage.
4. **File permissions testing**: When testing file permission errors, be aware that Unix-style permission bits don't translate directly to Windows.

The WFL compiler does not currently have any execution time limits implemented in the codebase. Milestone 7 (Interpreter Implementation/Execution Engine) would be an appropriate place to add execution time limits to prevent infinite loops or excessively long-running programs. This feature should be considered when designing the interpreter's execution model.

The WFL language uses strict type checking with type inference, meaning it catches type errors at compile time while allowing developers to omit explicit types where they can be inferred. The type system should include:

1. **Basic Types**: Primitive types (Number, Text, Boolean) and composite types (List, Map, etc.)
2. **Special Types**: Include `Type::Unknown` for inference, `Type::Error` for failed expressions, and `Type::Async<T>` for asynchronous operations
3. **Type Inference Strategy**: Use a single-pass approach where types are propagated up/down as needed, with functions like `type_of_expr(expr) -> Type` that recursively compute types
4. **Type Checking Rules**:
   - Binary operations: Ensure operands have compatible types
   - Assignments: Value type must be assignable to variable's type
   - Function calls: Arguments must match parameter types
   - Control flow: Branches must have compatible types
   - Async operations: Only awaitable expressions can be awaited

Type errors should be accumulated rather than stopping at the first error, with detailed messages including location information and expected vs. found types.

To reduce memory usage in the WFL parser:
1. **Avoid unnecessary cloning** of token data by borrowing token data where possible (e.g., peek by reference instead of using `cloned()`)
2. **Preallocate vectors** by using `reserve()` or initializing with estimated capacity to avoid repeated reallocations, especially in functions like `parse_primary_expression` and `parse_binary_expression`
3. **Implement string interning** for repeated identifiers and keywords to reduce duplicate string allocations
4. **Reduce temporary objects** by minimizing use of `format!` in tight loops and deferring error message construction until needed
5. **Review vector growth patterns** in parsing routines to identify opportunities for buffer reuse

The WFL project should include:
1. An MIT license file at the root of the repository
2. A credits document that lists all third-party Rust packages (dependencies) used in the project, including their names, versions, and licenses

These documentation files are important for proper attribution and legal compliance when distributing the WFL compiler.

The WFL project uses `cargo-deb` for Debian package creation with specific configuration requirements:

1. **Configuration file location**: A `.wflcfg` file must be created at `target/${TARGET}/release/package/.wflcfg` before running `cargo-deb`
2. **Configuration contents**: The file should contain settings like:
   ```
   timeout_seconds = 60
   logging_enabled = false
   debug_report_enabled = true
   log_level = info
   ```
3. **Package metadata**: Configuration for the Debian package is specified in `Cargo.toml` under the `[package.metadata.deb]` section
4. **Build process**: The packaging process includes creating both `.deb` packages and `.tar.gz` archives with versioned directories
5. **Installation requirements**: The WFL binary expects the configuration file to be installed at `/etc/wfl/.wflcfg` - missing this file causes "No such file or directory" errors when running the installed binary

When CI fails with "Static file asset path or glob pattern did not match any existing files" errors, it typically indicates the `.wflcfg` file wasn't properly created or placed in the expected location.

Once compiled, the WFL compiler produces standalone binaries that don't require Rust to be installed on the target system. This means end users can run WFL programs without installing the Rust toolchain, simplifying distribution and deployment.

The hello.wfl file in the Test Programs directory represents the standard for how WFL should be written, even though it may not parse correctly with the current implementation. When updating documentation or implementing parser features, hello.wfl should be used as the reference for correct syntax, not the current parser implementation. The documentation in wfl.md should be aligned with the syntax demonstrated in hello.wfl.

The WFL compiler follows a structured development roadmap with the following milestones:
1. Language Design Foundations
2. Project Setup and Tooling
3. Lexer (Tokenizer) Implementation
4. Parser and AST Construction
5. Semantic Analysis and Symbol Resolution
6. Static Type Checker
7. Interpreter Implementation (Execution Engine)
8. Standard Library and Core Features
9. Asynchronous I/O and Task Runtime Integration
10. Error Reporting and Diagnostics System
11. REPL (Read-Eval-Print Loop) Implementation
12. Editor/IDE Integration (Language Server Protocol)
13. Web Integration and Deployment

This roadmap follows standard compiler construction phases, with additional focus on web integration and developer tooling in the later stages.

The WFL language has control flow constructs including loops. The language supports "break" to exit the innermost loop, but also needs "exit loop" to break one level farther out than the current loop. Implementation requires updates to both the parser (to recognize the syntax) and the interpreter (to handle the control flow properly).

When implementing new control flow statements like "exit loop":
1. Store source position (line/column) in control flow enums to preserve error context when bubbling up
2. Update all pattern matches across the codebase that reference similar statements (search for "BreakStatement" and "ContinueStatement")
3. Clear all loop-specific state variables in every control flow branch
4. Add the static analyzer check for misused control flow before unreachable code analysis
5. Ensure special handling for infinite loops (ForeverLoop) to properly exit when control flow statements are encountered

GitHub Actions should be implemented to automatically run tests for the WFL project. This ensures continuous integration and verification that code changes don't break existing functionality. When implementing new features or making changes to the WFL compiler components (lexer, parser, bytecode compiler, etc.), ensure that GitHub Actions workflows are updated or created to test the relevant components.

WFL stands for "WebFirst Language," not "Work Flow Language." When working on the WFL project, ensure all documentation, comments, and user-facing messages correctly identify it as "WebFirst Language." This includes updating any existing references in the codebase that incorrectly identify it as "Work Flow Language."

After implementing the parser, WFL now has a valid syntax checker. When creating new test programs or language features, run them against the syntax checker to verify correctness. This can be done by using the main.rs file which now displays both lexer output and parser output, showing either the parsed AST or syntax errors with line and column information.

The WFL project uses a configuration system with two levels:

1. **Global Configuration**:
   - Linux/macOS: `/etc/wfl/wfl.cfg`
   - Windows: `C:\wfl\config`

2. **Local Configuration**:
   - `.wflcfg` file in the script's directory

**Lookup Order**:
1. Load from global config path first
2. Load from local `.wflcfg` in the script's directory
3. Local settings override global ones for overlapping keys

**Configuration Settings**:
- **General Runtime Settings**:
   - `timeout_seconds` (u64): Maximum execution time (minimum 1s, default 60s)
   - `logging_enabled` (bool): Enables log output to wfl.log (default false)
   - `debug_report_enabled` (bool): Enables debug reports on runtime errors (default true)
   - `log_level` (str): Log verbosity - debug, info, warn, error (default info)

- **Code Quality/Linter Settings**:
   - `max_line_length` (usize): Maximum line length (default 100)
   - `max_nesting_depth` (usize): Maximum control structure depth (default 5)
   - `indent_size` (usize): Spaces per indent level (default 4)
   - `snake_case_variables` (bool): Enforce snake_case variable names (default true)
   - `trailing_whitespace` (bool): Allow trailing whitespace (default false)
   - `consistent_keyword_case` (bool): Require consistent keyword casing (default true)

The configuration file uses an INI-like format with key-value pairs and can include comments starting with `#`.

**Testing Configuration**:
- When testing configuration loading, use `with_test_global_path(|| load_config_with_global(...))` to ensure environment variable overrides work correctly
- For tests that need both global and local configs, ensure the `WFL_GLOBAL_CONFIG_PATH` environment variable is properly set and respected
- Local config files should override specific keys from global config without clearing unmentioned keys

When encountering CI errors claiming that `std::env::set_var` and `std::env::remove_var` are unsafe functions (requiring unsafe blocks), this is likely due to shadowing or macro interference rather than actual safety issues. These functions are safe in standard Rust. To fix without using unsafe blocks:

1. Use fully qualified syntax to bypass potential conflicts:
   ```rust
   ::std::env::set_var("ENV_VAR_NAME", value)
   ::std::env::remove_var("ENV_VAR_NAME")
   ```

2. Check for accidental shadowing from imports like `use some_crate::env`

3. Investigate macro interference that might be redefining standard library functions

4. Consider moving environment variable manipulation to a separate helper function if the issue persists

When working on the WFL project, always submit pull requests directly rather than just creating them. After pushing changes to a branch, use the GitHub CLI command `gh pr create` with appropriate parameters to both create and submit the pull request in one step, rather than just pushing the branch and providing the URL for manual PR creation.